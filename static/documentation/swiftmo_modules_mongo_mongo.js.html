<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>SwiftMo Artistan Source: swiftmo_modules/mongo/mongo.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">SwiftMo Artistan</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="backendEventDelegation.html">backendEventDelegation</a></li><li><a href="backendEventDelegation.mainMenu.html">backendEventDelegation.mainMenu</a></li><li><a href="backendEventDelegation.selectAndEdit.html">backendEventDelegation.selectAndEdit</a></li><li><a href="clientEventDelegation.html">clientEventDelegation</a></li><li><a href="clientEventDelegation.modalMethods.html">clientEventDelegation.modalMethods</a></li><li><a href="imagesAPI.html">imagesAPI</a></li><li><a href="module-Database%2520interaction-stockAPI.html">Database interaction~stockAPI</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-Database%2520interaction.html">Database interaction</a></li><li><a href="module-multerFileUpload.html">multerFileUpload</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="CurrencyInput.html">CurrencyInput</a></li><li><a href="FuzzySearch.html">FuzzySearch</a></li><li><a href="SwiftCal.html">SwiftCal</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="backendEventDelegation.html#.event:Addtheme">backendEventDelegation.event:Add theme</a></li><li><a href="backendEventDelegation.html#.event:Deleteimage">backendEventDelegation.event:Delete image</a></li><li><a href="backendEventDelegation.html#.event:DOMContentLoaded">backendEventDelegation.event:DOMContentLoaded</a></li><li><a href="backendEventDelegation.html#.event:Filtersthestockitemsonthepagebyitem">backendEventDelegation.event:Filters the stock items on the page by item</a></li><li><a href="backendEventDelegation.html#.event:Hidethenextrelevantcontent">backendEventDelegation.event:Hide the next relevant content</a></li><li><a href="backendEventDelegation.html#.event:LoadEntityview">backendEventDelegation.event:Load Entity view</a></li><li><a href="backendEventDelegation.html#.event:Loginbuttonclick">backendEventDelegation.event:Login button click</a></li><li><a href="backendEventDelegation.html#.event:ResetFilters">backendEventDelegation.event:Reset Filters</a></li><li><a href="backendEventDelegation.html#.event:Showthenextrelevantcontent">backendEventDelegation.event:Show the next relevant content</a></li><li><a href="backendEventDelegation.html#.event:Stockaddapp.">backendEventDelegation.event:Stock add app.</a></li><li><a href="backendEventDelegation.selectAndEdit.Delete%2520a%2520thing,%2520e.g.html#.event:anitemtype">backendEventDelegation.selectAndEdit.Delete a thing, e.g.event: an item type</a></li><li><a href="backendEventDelegation.selectAndEdit.html#.event:Additemtype">backendEventDelegation.selectAndEdit.event:Add item type</a></li><li><a href="backendEventDelegation.selectAndEdit.html#.event:Addproducer">backendEventDelegation.selectAndEdit.event:Add producer</a></li><li><a href="backendEventDelegation.selectAndEdit.html#.event:Deleteitemtype">backendEventDelegation.selectAndEdit.event:Delete item type</a></li><li><a href="backendEventDelegation.selectAndEdit.html#.event:Editdimensions">backendEventDelegation.selectAndEdit.event:Edit dimensions</a></li><li><a href="backendEventDelegation.selectAndEdit.html#.event:Toggleeditmodal">backendEventDelegation.selectAndEdit.event:Toggle edit modal</a></li><li><a href="global.html#event:Clonesthespecifiednumberofaparticularitemtypewithaparticularpattern">event:Clones the specified number of a particular item type with a particular pattern</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#$">$</a></li><li><a href="global.html#addItemType">addItemType</a></li><li><a href="global.html#bookDay">bookDay</a></li><li><a href="global.html#dateOnClickEvents">dateOnClickEvents</a></li><li><a href="global.html#fieldCss">fieldCss</a></li><li><a href="global.html#generateTimesOnly">generateTimesOnly</a></li><li><a href="global.html#getArrayTypeInput">getArrayTypeInput</a></li><li><a href="global.html#Humandate">Human date</a></li><li><a href="global.html#makeDate">make Date</a></li><li><a href="global.html#makeQuestion">makeQuestion</a></li><li><a href="global.html#MakeScroller2">MakeScroller2</a></li><li><a href="global.html#makeTimeElements">makeTimeElements</a></li><li><a href="global.html#optData">optData</a></li><li><a href="global.html#range">range</a></li><li><a href="global.html#rangeSelect">rangeSelect</a></li><li><a href="global.html#releaseBookedDay">releaseBookedDay</a></li><li><a href="global.html#releaseDayOfWeekG">releaseDayOfWeekG</a></li><li><a href="global.html#removeTime()">removeTime()</a></li><li><a href="global.html#reqVal%2522requestvalidation%2522">reqVal "request validation"</a></li><li><a href="global.html#resetItemFields">resetItemFields</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: swiftmo_modules/mongo/mongo.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/*jshint esversion: 6 */
/**
 * Mongo interface
 * @module Database interaction
 * @description Methods for database interaction
 */

/**
 * Stock
 * @namespace stockAPI
 * @description Stock consultation functions.
 */


  const db = function(){
    return swiftMod('MongoConnect').getDb();
  };
  const fs = require('fs');
  const ObjectId = require('mongodb').ObjectID;
  const any = swiftMod('any').any;
  const folderContent = swiftMod('syncFolder').getArrayWithAllPathsInDir;

  let entity = db().db('pottery').collection('entity');
  let stock = db().db('pottery').collection('stock');
  let blog = db().db('pottery').collection('blog');
  let carts = db().db('pottery').collection('carts');
  let clients = db().db('pottery').collection('clients');
  let shipping = db().db('pottery').collection('shipping');
  const encryptor = swiftMod('encryption');
  //let checkInput = require('./checkUserInput').inputcheck;

/**
 * @typedef Boolean
 * @property {bool} Promise resolving a Boolean value.
 */

/**
 * Check itemref collision.
 * @param {object} itemref - example input: {itemref: '098p0p00'}
 * @description Checks the database if a given itemref exist.
 * @returns {Promise&lt;Boolean>} Resolves a Boolean indicating whether to generate a new
 * itemref or not.
 */
  exports.checkCollision = (itemref)=>{
    let promise = new Promise((resolve, reject)=>{

      stock.findOne(itemref, function(err, results){
        if (err) reject(err);
        if(!results){
          resolve(false)
        }
        else{
          resolve(true);
        }
      });
    });
    return promise;
  }

/**
  * Get all items in stock and condences similar items by pattern and type
  * @summary Call this with no parameters to get all post titles.
  * @description Returns all unsold items in stock.
  * @returns {Promise&lt;Array>} Resolves an array with all all unsold items in stock.
  * @memberof stockAPI
  */
exports.getDistinctItems = ()=>{
  let promise = new Promise((resolve, reject)=>{
    stock.aggregate([
      // group by key, score to get distinct
      //, "item type.name":"$type", "theme.name":"$pattern"
      {"$match" :{"$and": [{"cart.status.checkOut": {$exists: false}}, {"master item type": {$exists: false}}]}},
      {"$group" : {
        _id : {
          "weight":"$item type.weight",
          "type": "$item type.name",
          "pattern": "$theme.name",
          "dimensions": "$item type.dimensions"
        },
          count: { $sum: 1 },
          items: { $push: {itemref: "$itemref"}},
          //image: { $first: '$image links'}

          image: { $push: '$image links'}
        }
      },
      // Clean up the output
      //{"$project" : {_id:0, key:"$_id.key", score:"$_id.score"}}
      ]).toArray(function(err, result){
          if (err) reject(err);

          resolve(result);
        });
  });
  return promise;
}

/**
  * Get post titles
  * @summary Call this with no parameters to get all post titles.
  * @description Returns all the titles of all the blog posts. Posts aren't
  * expelicitly linked, rather they are dynamically linked via their title.
  * @returns {Promise&lt;Array>} Resolves an array with all the blog post titles.
  * @memberof blog
  * @see backendEventDelegation
  */
  exports.getPostTitles = ()=>{
    let promise = new Promise((resolve, reject)=>{
      blog.find({}).project({_id: 0, title: 1}).toArray((err, results)=>{
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  }

  exports.adminLogin = (loginData)=>{
    let promise = new Promise((resolve, reject)=>{
      entity.findOne({}, function(err, results){
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  };

  exports.entityDetails = ()=>{
    let promise = new Promise((resolve, reject)=>{
      entity.find({name: 'Porches Pottery'}).project(
        {_id: 0, username: 0, password: 0}).toArray((err, results)=>{
          if (err) reject(err);
          resolve(results);
        });
    });
    return promise;
  };

  /**
   * Update a single document field in enity
   * @param {object} update - {itemref: '098poi0p', [field to update]: 'update value'}
   * @returns {promise} success or failure
   * @summary It searches for any field in entity because there should just be one.
   */
  exports.updateEntity = (update)=>{
    let promise = new Promise(function(resolve, reject){
      entity.updateOne({},{$set: update},{upsert: false}, function(err, result){
        if (err) reject(err);
        resolve(result);
      });
    });
    return promise;
  };

  exports.validateLogin = (loginData, callback)=>{
    let promise = new Promise((resolve, reject)=>{
      let query =  {username: loginData.username, password: loginData.password};
      entity.findOne(query, function(err, results){
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  };

  exports.getStock = ()=>{
    let promise = new Promise(function(resolve, reject){
      stock.find({}).toArray(function(err, results){
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  };

  exports.createItem = (req, cb)=>{
    let finalreq = (Array.isArray(req)) ? req : [req];
    let promise = new Promise((resolve, reject)=>{
      try{
        stock.insertMany(finalreq).then((rep)=>{
            resolve('OK');
          }
        );

      }catch(e){
        reject(e);
      }
    });
    return promise;
  }

  exports.getItem = (itemref)=>{
    let promise = new Promise(function(resolve, reject){
      stock.find(itemref).toArray(function(err, results){
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  };

  exports.deleteItem = (itemref)=>{
    let promise = new Promise(function(resolve, reject){
      resolve(stock.deleteOne(itemref));
    });
    return promise;
  };

  exports.updateItem  = (req, callback) => {
    let promise = new Promise((resolve, reject)=>{
      (async function saveUpdate(){
        stock.updateOne(
          { itemref: req.updates.itemref},
          {$set: req.updates},
          {upsert: true},
          function(err, result){
            if (err) reject(err);
            resolve(result);
          });
      })();
    });
    return promise;
  }

  /**
   * Takes an object in req containing an array of items to update and updates those specific stock items with a cart status.
   * @param {Object} {itemrefs: [], 'cart status': {'added to cart': new Date().getTime()}}
   * @description
   *
   * This is callable like so:
   *   let update = await mongo.updateManyItems ({
   *     itemrefs: {Obeject[]},
   *     cart: {
   *     cartcode: cartcode,
   *     'cart status': {'added to cart': new Date().getTime()}
   *    }
   *   });
   *
   */
  exports.updateManyItems  = (updates, callback) => {
    let promise = new Promise((resolve, reject)=>{
      (async function saveUpdate(){
        stock.bulkWrite([
          //add item
          {updateMany: {
              filter: {itemref: {$in: updates.itemrefs}},
              update: {$set: {cart: updates.cart}},
              upsert: true,
          }},
          //remove item
          {updateMany: {
              filter: {itemref: {$nin: updates.itemrefs}, 'cart.cartcode' : updates.cart.cartcode},
              update: {$set: {cart: {sessionID: '', cartcode:'', status:{}, itemrefs: [], shippingDestination: ''}}},
              upsert: false,
          }}
        ],
        //options
        null,
        function(err, result){
          if (err) reject(err);

          if(result.result.ok){
            resolve(result);
          }
        }
      );

      })();
    });
    return promise;
  }









  exports.insertCart = (cart, callback) => {
    let promise = new Promise((resolve, reject)=>{
      try{
        carts.insertOne(cart).then((rep)=>{
            resolve();
          }
        );

      }catch(e){
        reject(e);
      }
    });
    return promise;
  }

  /**
    * Update cart in cart collection
    * @summary Updates a clients cart (separate from the embeded carts in stock objects)
    * @param {Object} {clientcode: cart.clientcode, itemrefs: cart.itemrefs, shippingDestination: cart.shippingDestination, 'status.checkOut': new Date().getTime()};
    * @description Updates a cart with any changeable information (i.e. leaves cartcode, _id etc alone)
    * @returns {Promise} Returns an empty promise.
    * @todo Write a check on input values.
    * @memberof cart
    */
  exports.updateCart = (cart) => {
    //let sessionID = cart.sessionID;
    //delete cart.sessionID;

    let promise = new Promise((resolve, reject)=>{
        carts.updateOne(
          {cartcode: cart.cartcode, "status.checkOut": {$exists: false}},
          //{cartcode: cart.cartcode},
          {$set: cart},
          {upsert: true},
          function(err, result){
            if (err) reject(err);
            resolve();
          });
    });
    return promise;
  }

  /**
    * Get cartcode
    * @summary Gets a valid cart object (one that is pending checkOut for the current session)
    * @param {Object} {sessionID: req.sessionID};
    * @description Gets one valid cart based on the current sessionID.
    * @returns {Promise} Returns a promise containing the cart code;

    * @memberof cart
    */
  exports.getCartCode = (req) => {
    return getCartCode(req);
  }

  function getCartCode(req){
    let promise = new Promise((resolve, reject)=>{
      carts.find({sessionID: req.sessionID, 'status.added': {$exists: true}})
        .project({_id: 0, cartcode: 1})
        .limit(1)
        .toArray(function(err, results){
          if (err) reject(err);

          resolve(results[0]);
        });
    });
    return promise;
  }

  //called from fetchCartData
  exports.returnCartItems = (req, callback) => {
    let promise = new Promise((resolve, reject)=>{
      try {
        (async()=>{
          let cartcode = await getCartCode(req);

          if(cartcode){
            let cartItems = await getAllItemsInCart(cartcode);
            resolve(cartItems);
          }else{
            resolve([]);
          }
        })();
      } catch (e) {
        console.warn(err);
      }
    });
    return promise;

  };

  function getAllItemsInCart(cartcode){
    let promise = new Promise((resolve, reject)=>{
      let code = (cartcode &amp;&amp; cartcode.cartcode) ? cartcode.cartcode : '';
      let query = [
        {"$match" : {"$and": [{'cart.cartcode': code, "cart.status.checkOut": {$exists: false}}, {"master item type": {$exists: false}}]}},
        {"$group" : {
          _id : {
            "weight":"$item type.weight",
            "type": "$item type.name",
            "pattern": "$theme.name",
            "dimensions": "$item type.dimensions"
          },
            firstExample: { $first: "$$CURRENT" },
            count: { $sum: 1 },
            weight: { $sum: "$item type.weight"},
            items: { $push: "$itemref"},
            image: { $first: '$image links'},
            cart: { $first: "$cart"}
          }
        },
      ];

      stock.aggregate(query).toArray(function(err, result){
            if (err) reject(err);


            resolve(result);
          });

    });
    return promise;
  }





  /**
    * getSalesPendingShipping -takes no parametes
    * @description
      Fetches all items from the database that have been purchased by clients and
       need to be shipped.
    * @returns {Promise}
      The promis object contains an array with all items to be shipped.
    * @memberof stockAPI
    * @todo Finish documentation!
    */
  exports.getSalesPendingShipping = ()=>{
    let promise = new Promise((resolve, reject)=>{
      stock.find({"cart.status.checkOut": {$exists: true}, "master item type": {$exists: false}})
        .toArray(function(err, result){
          if (err) reject(err);

          resolve(result);
      });
    });
    return promise;
  }

  /**
   * Update a single document field.
   * @param {object} update - {itemref: '098poi0p', [field to update]: 'update value'}
   * @returns {promise} success or failure
   */
  exports.updateItemField = (update)=>{
    let itemref = update.itemref;
    delete update.itemref;
    let promise = new Promise(function(resolve, reject){
      stock.updateOne({itemref: itemref},{$set: update},{upsert: false}, function(err, result){
        if (err) reject(err);
        resolve(result);
      });
    });
    return promise;
  };

  exports.getMasterItemType = ()=>{
    let promise = new Promise(function(resolve, reject){
      stock.find({'master item type': true}).toArray(function(err, results){
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  };


/**
  * Update array item
  * @description The key of the parent value being updated is the array
  * field to be updated in the array.
  *
  */
  exports.updateArrayItem = function(updates, callback){
    let id = updates._id;
    delete updates._id;

    let promise = new Promise((resolve, reject)=>{
      stock.updateOne(
        { 'master item type': true},
          {$push:
            updates
          },
        {upsert: true}, function(err, result){
        if (err) reject(err);
        resolve(result);
      });
    });
    return promise;
  };


  function exists(field, name){
    let query = { [field]: name};

    let promise = new Promise((resolve, reject)=>{
      stock.findOne(query, function(err, results){
        if (err) reject(err);
        if(!results){
          resolve(false);
        }else{
          resolve(true)
        }
      });
    });
    return promise;
  }

  /**
    * Check duplicate emails
    */
  exports.checkEmail = (req, cb) =>{
    let query = {email: req};
    //let query = {clientcode: req.clientcode};
    let promise = new Promise((resolve, reject)=>{
      clients.findOne(query, function(err, results){
        if (err) reject(err);
        if(!results){
          resolve(false);
        }else{
          resolve(results)
        }
      });
    });
    return promise;
  }

  /**
    * Check duplicate emails
    */
  exports.checkClientcode = (req, cb) =>{
    let query = {clientcode: req.clientcode};
    let promise = new Promise((resolve, reject)=>{
      clients.findOne(query, function(err, results){
        if (err) reject(err);
        if(!results){
          resolve(false);
        }else{
          let storedEmail = encryptor.decrypt(results.email);
          if(storedEmail === req.email){
            resolve(results)
          }
        }
      });
    });
    return promise;
  }

  /**
   * Add new and save OR update
   * @param {object} { dimensions: [ 290, 40, 290 ],weight: 900, name: 'large plate'}
   * @description Checks the database if a given item type exist, if it does
   * it updates it, else it creates a new item
   * @return {object} Mongo result modified true or not
   */
  exports.updateItemType = (req, path, callback) => {
    
    let promise = new Promise((resolve, reject)=>{
      (async function saveUpdate(){
        let type = req.updates.itemtype;
            delete req.updates.itemtype;
        let name = req.updates.name;

        let query = { 'master item type': true, [type+'.name']: name};
        
        let getCurrent = await stock.find(query).project({_id: 0, [type]: 1}).toArray();

        let specificTheme = (()=>{
          if(getCurrent &amp;&amp; getCurrent[0] &amp;&amp; getCurrent[0][type]){
            for (var i = 0; i &lt; getCurrent[0][type].length; i++) {
              if(getCurrent[0][type][i].name === name){
                return getCurrent[0][type][i];
              };
            }
          }
        })();

        if(req.updates['image links']){
          let paths = await folderContent(path);
          req.updates['image links'] = paths;
        }


        
        //if the item type exists:
        if(getCurrent &amp;&amp; getCurrent.length > 0){
          
          
          let newUpdates = Object.assign(specificTheme, req.updates);
          let updates = {[type+'.$']: newUpdates};

          stock.findOneAndUpdate(query,{$set:updates},{upsert: true}, (err, result)=>{
              if (err) reject(err);
              resolve(result);
            });
        }
        else{
          let query = { 'master item type': true},
              update = { [type]:req.updates };

          stock.updateOne(query,{$push: update},{upsert: true}, (err, result)=>{
              if (err) reject(err);
              resolve(result);
            });
        }

      })();
    });
    return promise;
  }


  exports.makeNewItemType = (req, callback) => {

    let promise = new Promise((resolve, reject)=>{
      stock.updateOne(
        { 'master item type': true},
          {$push:
            { 'item type':
              {name: req.name, dimensions: [0,0,0], weight: 0} }},
              {upsert: true},
        function(err, result){
          if (err) reject(err);
          resolve(result);
        });
    });
    return promise;
  }

  /**
   * Add new and save OR update
   * @param {object} { dimensions: [ 290, 40, 290 ],weight: 900, name: 'large plate'}
   * @description Checks the database if a given item type exist, if it does
   * it updates it, else it creates a new item
   * @return {object} Mongo result modified true or not
   */
  exports.updateTheme = (req, callback) => {

    let promise = new Promise((resolve, reject)=>{
      (async function saveUpdate(){
        let exist = await exists('theme.name', req.theme.value);
        if(!exist){
          stock.updateOne(
            { 'master item type': true},
              {$push:
                { 'theme':
                  {name: req.theme.value, images: req.theme['image links'] || []} }},
                  {upsert: true},
            function(err, result){
              if (err) reject(err);
              resolve(result);
            });
        }
        else{
          stock.updateOne(
            { 'master item type': true,
            'theme':
              //{ $elemMatch:
                { 'theme.name': req.theme.value }
              //}
            },
            {$set:
              {'theme.$' : req.theme}
            },{upsert: true}, function(err, result){
              if (err) reject(err);
              resolve(result);
            });
        }
      })();
    });
    return promise;
  }


  exports.makeNewItemType = (req, callback) => {

    let promise = new Promise((resolve, reject)=>{
      stock.updateOne(
        { 'master item type': true},
          {$push:
            { 'item type':
              {name: req.name, dimensions: [0,0,0], weight: 0} }},
              {upsert: true},
        function(err, result){
          if (err) reject(err);
          resolve(result);
        });
    });
    return promise;
  }


  exports.deleteItemType = (req) => {
    let promise = new Promise((resolve, reject)=>{
      let name = (req.name === '') ? '' : req.name;
      let query =   {$pull:{[req.type]: { name: name }}};
      stock.updateOne({ 'master item type': true}, query, (err, result)=>{
        if (err) reject(err);

        resolve(result.result.nModified);
      });
    });
    return promise;
  }

  /**
   * Get all themes
   * @description Gets all themes listed in the master item.
   * @return {Object[]} Returns an array in the form
   * @todo As a route predominantly used on the front end, this might be good to refractor.
   */
  exports.getAllThemes = (req) => {
    let promise = new Promise((resolve, reject)=>{
      stock.find({'master item type': true}).project({_id: 0, theme: 1}).toArray((err, results)=>{
        if (err) reject(err);
        let themes = results[0].theme;
        let filtered = [];
        let bespoke = [];
        for (var i = 0; i &lt; themes.length; i++) {
          if(!themes[i]['for bespoke'] === true){
            filtered.push(themes[i]);
          }else{
            bespoke.push(themes[i]);
          }
          if(i === themes.length-1){
            resolve([{theme: filtered, bespoke: bespoke}]);
          }
        }
      });
    });
    return promise;
  }

  /**
   * Get all stock for particular theme DB call
   * @param {Object} theme or shape -An object containing whether to query by theme or by shape.
   * @description Get all available stock with a particular theme or shape
   * @return {Object[]} Returns an array in the form [{item}, {item} ] where each item
   * represents a singular time (i.e. if there are more than one of an item, only one is returned.).
   */
  exports.stockQuery = (req)=>{
    let choice = (req.theme) ?
                  {'theme.name': req.theme} :
                    (req.shape) ?
                      {'item type.name': req.shape} : {'special': true};
    let promise = new Promise((resolve, reject)=>{
      let query = [
        {"$match" : {"$and": [choice, {"cart.status.checkOut": {$exists: false}}, {"cart.status.added": {$exists: false}}, {"templateItem": false}, {"master item type": {$exists: false}}]}},
        {"$group" : {
          _id : {
            "weight":"$item type.weight",
            "type": "$item type.name",
            "pattern": "$theme.name",
            "dimensions": "$item type.dimensions"
          },
            firstExample: { $first: "$$CURRENT" },
            count: { $sum: 1 },
            //items: { $push: {itemref: "$itemref"}},
            items: { $push: "$itemref"},
            image: { $first: '$image links'}
          }
        },
        //{ $replaceRoot: { newRoot: '$firstExample' } }

      ];
      stock.aggregate(query).toArray(function(err, result){
            if (err) reject(err);

            resolve(result);
          });
    });
    return promise;
  }


  /**
   * Get the full document by distinct value (pass the value to be queried in req)
   * @param {string} field name to be queried e.g. "name" returns a single item for each name.
   * @description Gets a single item for each distinct value for the field queried.
   * @return {Object[]} Returns an array in the form
   */
  exports.getFullDocumentByDistinctValue = (req) => {
    let promise = new Promise((resolve, reject)=>{
      let value = '$' + req
      //stock.aggregate([{$group: {_id: value, doc : {$first: "$$ROOT"}}}]).toArray(function(err, result){
      stock.aggregate([
        //exclude master item type and null fields
        {$match: { 'master item type': { $exists: false }, [req] : {$ne : null}}},
        //group by name and return the first document
        {$group: {_id: value, doc : {$first: "$$ROOT"}}}
      ]).toArray(function(err, result){
          if (err) reject(err);

          let flat = [];
          for (let i = 0; i &lt; result.length; i++) {
            flat.push(result[i].doc);
            if(i === result.length-1){
              resolve(flat);
            }
          }
        });
    });
    return promise;
  }

  /**
   * Get all distinct Item Types.
   * @return {Object[]} Returns an array in the form
   */
  exports.distinctItemType = (req) => {
    let promise = new Promise((resolve, reject)=>{
      stock.distinct('name', {}, (err, results)=>{
        if (err) reject(err);
        resolve(results);
      });
    });
    return promise;
  }

  /**
   * Register Client
   */
   exports.registerClient = (req) =>{
     let promise = new Promise((resolve, reject)=>{
       clients.insertOne(req, (err, results)=>{
         if (err) reject(err);
         resolve(results);
       });

     });
     return promise;
   }

  /**
   * Get all available themes for a particular item type
   * @description Get all available themes for a particular item type.
   * @param {Object} {'name': 'coaster'}
   * @return {Object[]} Returns an array in the form
   */
  exports.getThemesForItemType = (req) => {
    let promise = new Promise((resolve, reject)=>{
        stock.aggregate([
          //exclude master item type and null fields
          {$match: { 'master item type': { $exists: false }, name: 'Coaster' }},
          //group by name and return the first document
          {$group: {_id: '$theme.name', doc : {$first: "$$ROOT"}}}
        ]).toArray(function(err, result){
            if (err) reject(err);
            let flat = [];

            for (let i = 0; i &lt; result.length; i++) {
              flat.push(result[i].doc);
              if(i === result.length-1){

                resolve(flat);
              }
            }
          });
    });
    return promise;
  }

  /**
   * Get Shipping cost
   * @description Gets shipping cost based on country.
   * @param {Object} {country: country, weight: weight}
   * @return {int} Returns the cost of shipping
   */
   exports.getShippingCost = (req) => {
     let promise = new Promise((resolve, reject)=>{
        shipping.find({}).project({_id: 0}).toArray((err, result)=>{
          if (err) reject(err);
          let priceObject = result[0],
              country = (req.country.includes('|')) ? req.country.split('|')[1] : req.country;
              weight = req.weight;
          let indexCountry = ()=>{
            for (let i = 0; i &lt; priceObject.countries.length; i++) {
              if(priceObject.countries[i].includes(country)){
                return i;
              }
              else if(i === priceObject.countries.length-1){
                return i;
              }
              else{
                continue;
              }

            }
          };

          let indexWeight = ()=>{
            return priceObject.weight.indexOf(priceObject.weight.filter(x => x > weight)[0]);
          }

          let price = priceObject.prices[indexCountry()][indexWeight()];

          let weightLeft = priceObject.weight[indexWeight()] - weight;


          let shipping = {country: country, price: price, vat: priceObject.vat, weightLeft: weightLeft, currentWeight : weight};

          resolve(shipping);
        });
     });
     return promise;
   }

 /**
 * accepts a title only, ignores params, and directories.
 */
exports.getBlogs = function(req, res){
 let path = (req.slice(0,1) === '/') ? req.replace('/', '') : req;
 let promise = new Promise((resolve, reject)=>{
   blog.find({title: path}).toArray((err, result)=>{
     if(err) reject(err);
     resolve(result[0]);
   });
 });
 return promise;
};

exports.getTopics = function(req, res){
 let promise = new Promise((resolve, reject)=>{
   blog.find({}).project({topics : 1, _id: 0}).toArray((err, result)=>{
     if(err) reject(err);
     let uniquesSkinned = [...new Set(result)].map(item => item.topics[0]);
     resolve(uniquesSkinned);
   });
 });
 return promise;
};

exports.getBlogsViaQuery = function(req, res){
 let promise = new Promise((resolve, reject)=>{

   blog.find(req).toArray((err, results)=>{
     if(err) reject(err);
     resolve(results);
   });
 });
 return promise;
};

exports.blogsave = function(req, res){
 let id = req.body._id;
 delete req.body._id;
 //req.body.provider = req.user.provider;
 let promise = new Promise((resolve, reject)=>{
   blog.updateOne({_id: ObjectId(id), provider: req.user.provider},
   {$set: req.body},{upsert: false}, function(err, result){
     if (err) reject(err);
     resolve(result);
   });
 });
 return promise;
};

exports.blogsaveimages = function(req, res){
 let promise = new Promise((resolve, reject)=>{
   let id = (req.body._id === 'undefined') ? ObjectId() : ObjectId(req.body._id);
   blog.updateOne({_id: id, provider: req.user.provider},
   {$push:{content: {el: 'img', cont: req.body.image}}}, {upsert: false}, function(err, result){
     if (err) reject(err);
     resolve(result);
   });
 });
 return promise;
};

exports.removeContentElement = function(req, res){
  let promise = new Promise((resolve, reject)=>{
    let id = req.body._id;
    blog.updateOne({_id: ObjectId(id), provider: req.user.provider},
    {$pull:{content: req.body.item}}, {upsert: false}, function(err, result){
      if (err) reject(err);
      resolve(result);
    });
  });
  return promise;
};


exports.blogsavenew = function(req, res){
  let promise = new Promise((resolve, reject)=>{
    blog.insertOne(req, function(err, res) {
      if (err) reject(err);

      resolve({'_id': res.ops[0]._id});
    });
  });
  return promise;
};

exports.blogPostExists = function(query){
  let promise = new Promise(function(resolve, reject){

    blog.findOne({title: query}, {"_id" : 1}, function(err, results){
      if (err) reject(err);
      if(results &amp;&amp; results.title &amp;&amp; results.title === query){
        resolve(true);
      }
      else{
        resolve(false);
      }
    });
  });
  return promise;
};


exports.blogdelete = function(req, res){
  let promise = new Promise((resolve, reject)=>{

    if(!req._id){
      blog.find({title: req.title})
        .toArray()
        .then(result)
        .then(blog.deleteOne({_id: result._id}))
        .then(result => console.warn(`Deleted ${result.deletedCount} items.`))
        .catch(err => console.error(`Delete failed with error: ${err}`));
    }
    else{
      blog.deleteOne({_id: ObjectId(req._id)})
        .then(result => console.warn(`Deleted ${result.deletedCount} item.`))
        .catch(err => console.error(`Delete failed with error: ${err}`));
    }
  });
  return promise;
};
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright Â© 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
	
		on Thu Nov 5th 2020
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
